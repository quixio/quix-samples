from typing import Union, Callable, Iterable, Optional
import os

from quixstreams import Application
from quixstreams.sinks.community.tdengine.sink import (
    TDengineSink,
    FieldsSetter,
    TagsSetter,
    SupertableSetter,
    SubtableNameSetter,
    TimeSetter
)

# for local dev, load env vars from a .env file
from dotenv import load_dotenv
load_dotenv()


def _as_bool(env_var: str) -> bool:
    return os.getenv(env_var, "false").lower() == "true"


def _as_iterable(env_var) -> list[str]:
    return keys.split(",") if (keys := os.getenv(env_var)) else []


def _as_int(env_var, default) -> int:
    return int(os.getenv(env_var, default))


def _as_float(env_var, default) -> float:
    return float(os.getenv(env_var, default))


def _get_tdengine_subtable_name(
    tags_keys: Union[Callable[[dict], Iterable[str]], Iterable[str]]
) -> Callable[[dict], Optional[str]]:
    """
    TDengine names subtables based on each unique combination of tag values.
    By default, the names are randomized like `t_dc7d907438b41235ca431e52392ac2a4`,
    which occurs when you do not pass an explicit name (`None`).

    This allows you to instead name them something human-readable using a record's
    combined tag values, ex. `host1__USA` for tags (hostname, region).
    """
    if not _as_bool("TDENGINE_NAME_SUBTABLES_FROM_TAGS"):
        # uses names auto-generated by TDengine (via hash)
        return lambda row: ""

    def _subtable_name(row: dict):
        _tags_keys = tags_keys(row) if callable(tags_keys) else tags_keys
        return "__".join([str(row[tk]) for tk in _tags_keys])

    return _subtable_name


# Potential Callables - can manually edit these to instead use your own callables.
# --Required--
supertable: SupertableSetter = os.getenv("TDENGINE_SUPERTABLE")
# --Optional--
tags_keys: TagsSetter = _as_iterable("TDENGINE_TAGS_KEYS")
fields_keys: FieldsSetter = _as_iterable("TDENGINE_FIELDS_KEYS")
subtable: SubtableNameSetter = _get_tdengine_subtable_name(tags_keys)
time_setter: Optional[TimeSetter] = col if (col := os.getenv("TIMESTAMP_COLUMN")) else None


# Authentication: supports both token (Cloud) and username/password (On-Premise)
token = os.getenv("TDENGINE_TOKEN", "")
username = os.getenv("TDENGINE_USERNAME", "")
password = os.getenv("TDENGINE_PASSWORD", "")

# Build sink kwargs based on available auth credentials
sink_kwargs = {
    "host": os.environ["TDENGINE_HOST"],
    "database": os.environ["TDENGINE_DATABASE"],
    "supertable": supertable,
    "subtable": subtable,
    "fields_keys": fields_keys,
    "tags_keys": tags_keys,
    "time_setter": time_setter,
    "time_precision": os.environ["TDENGINE_TIME_PRECISION"],
    "allow_missing_fields": _as_bool("TDENGINE_ALLOW_MISSING_FIELDS"),
    "include_metadata_tags": _as_bool("TDENGINE_INCLUDE_METADATA_TAGS"),
    "convert_ints_to_floats": _as_bool("TDENGINE_CONVERT_INTS_TO_FLOATS"),
    "enable_gzip": _as_bool("TDENGINE_ENABLE_GZIP"),
    "max_retries": _as_int("TDENGINE_MAX_RETRIES", 5),
    "retry_backoff_factor": _as_float("TDENGINE_RETRY_BACKOFF_FACTOR", 1.0)
}

# Add auth credentials
if token:
    sink_kwargs["token"] = token
elif username and password:
    sink_kwargs["username"] = username
    sink_kwargs["password"] = password
else:
    raise ValueError("Either TDENGINE_TOKEN (for Cloud) or TDENGINE_USERNAME and TDENGINE_PASSWORD (for On-Premise) must be provided")

tdengine_sink = TDengineSink(**sink_kwargs)


app = Application(
    consumer_group=os.getenv("CONSUMER_GROUP_NAME", "tdengine-data-writer"),
    auto_offset_reset="earliest",
    commit_every=_as_int("BUFFER_SIZE", 1000),
    commit_interval=_as_float("BUFFER_DELAY", 1.0),
)
input_topic = app.topic(os.environ["input"])
app.dataframe(input_topic).sink(tdengine_sink)


if __name__ == "__main__":
    app.run()
